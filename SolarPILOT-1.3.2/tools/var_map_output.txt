ambient
	setVar("atm_coefs", _atm_coefs, V);		//Atmospheric attenuation coefficients for user-defined analysis
	setVar("atm_model", _atm_model, V, 0, "[0,3]");		//Atmospheric attenuation model {0=25km Barstow, 1 = 5km Barstow, 2 = user defined}
	setVar("class_name", _class_name, V, "Climate");		//Class name
	setVar("date_mday", _date_time._mday, V, _date_time._mday, "[1,31]");		//Day of the month setting for date object
	setVar("date_month", _date_time._month, V, _date_time._month, "[1,12]");		//Month setting for date object
	setVar("date_wday", _date_time._wday, V, _date_time._wday, "[1,7]");		//Day of the week setting for date object
	setVar("date_yday", _date_time._yday, V, _date_time._yday, "[1,365]");		//Day of the year  setting for date object
	setVar("date_year", _date_time._year, V, _date_time._year, "[0.,2150.]");		//Year setting for date object
	setVar("del_h2o", _del_h2o, V, 20., "[0,9e9]");		//Atmospheric precipitable water depth for use in the Allen insolation model
	setVar("dni_layout", _dni_layout, V, 950., "[0,9999]");		//DNI to use during all layout calculations. CONSTANT model only.
	setVar("dpres", _dpres, V, 1., "[0,2]");		//Local ambient pressure relative to sea-level pressure
	setVar("elevation", _elevation, V, 588., "[-424.,8850.]");		//Plant mean elevation
	setVar("insol_type", _insol_type, V, -1, "[-1,4]");		//Model used to determine insolation as a function of time
	setVar("latitude", _latitude, V, 34.867, "[-90.,90.]");		//Plant latitude
	setVar("longitude", _longitude, V, -116.783, "[-180.,180.]");		//Plant longitude
	setVar("sun_azimuth", _azimuth, V, 0., "[-180.,180.]");		//User-set solar azimuth angle
	setVar("sun_csr", _sun_csr, V, 0.1, "[0,1)");		//Ratio of solar flux contained in the circumsolar ring over the solar disc flux
	setVar("sun_pos_map", _sun_pos, V);		//Map of sun positions to use for calculations
	setVar("sun_rad_limit", _sun_rad_limit, V, 4.65, "(0,1000]");		//Half-angle of sunshape size (4.65mrad for Pillbox, 2.73mrad for Gaussian)
	setVar("sun_type", _suntype, V, 1, "[0,3]");		//Sunshape model - {0=point sun, 1=limb darkened sun, 2=square wave sun, 3=user sun}
	setVar("sun_zenith", _zenith, V, 0.5, "[0.,90]");		//User-set solar zenith angle
	setVar("time_hour", _date_time._hour, V, _date_time._hour, "[0,24)");		//Hour of the day setting for date object
	setVar("time_min", _date_time._min, V, _date_time._min, "[0,60)");		//Minute of the hour setting for date object
	setVar("time_ms", _date_time._ms, V, _date_time._ms, "[0,1000)");		//Millisecond of the second setting for date object
	setVar("time_sec", _date_time._sec, V, _date_time._sec, "[0,60)");		//Second of the minute setting for date object
	setVar("time_zone", _time_zone, V, -8., "[-12,12]");		//Time zone
	setVar("user_sun", _user_sun, V);		//Array of intensity at various angles from the centroid of the sun
	setVar("weather_file", _weather_file, V, "CA Daggett.tm2");		//Weather file to use for analysis
	setVar("wf_data", _wf_data, V);		//Data entries in the weather file
	setVar("wf_type", _wf_type, V, "TM2");		//weather file type {TM2, TM3, SMW, EPW, USER}
financial
	setVar("class_name", _class_name, V, "Financial");		//Class name
	setVar("contingency_cost", _contingency_cost, V, 0.);		//Contingency cost
	setVar("contingency_rate", _contingency_rate, V, 7.);		//Fraction of the direct capital costs added to account for contingency
	setVar("cost_per_capacity", _cost_per_capacity, V, 0.);		//Estimated capital cost per capacity (net)
	setVar("fixed_cost", _fixed_cost, V, 0.);		//Cost that does not scale with any plant parameter
	setVar("heliostat_area", _heliostat_area, V);		//Solar field reflective area (omits panel gaps)
	setVar("heliostat_cost", _heliostat_cost, V, 0.);		//Heliostat field cost
	setVar("heliostat_spec_cost", _heliostat_spec_cost, V, 180., "[-9e9,9e9]");		//Cost per square meter of heliostat aperture area of the heliostat field
	setVar("is_pmt_factors", _is_pmt_factors, V, false);		//Enable or disable the use of weighting factors in determining field layout
	setVar("land_cost", _land_cost, V, 0.);		//Land cost
	setVar("land_const", _land_const, V, 45.);		//Fixed land area that is added to the area occupied by heliostats
	setVar("land_mult", _land_mult, V, 1.3);		//Factor multiplying the land area occupied by heliostats
	setVar("land_area_tot", _land_area_tot, V, 0.);		//Total calculated land area
	setVar("land_spec_cost", _land_spec_cost, V, 10000.);		//Cost of land per acre including the footprint of the land occupied by the entire plant.
	setVar("plant_cost", _plant_cost, V, 0.);		//Cost of the power block and balance of plant equipment
	setVar("plant_spec_cost", _plant_spec_cost, V, 1200.);		//Cost of the power block and balance of plant equipment per kilowatt (electric) gross design power
	setVar("pmt_factor_1", _pmt_factor_1, V, 2.064);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_2", _pmt_factor_2, V, 1.2);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_3", _pmt_factor_3, V, 1.);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_4", _pmt_factor_4, V, 1.1);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_5", _pmt_factor_5, V, 0.8);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_6", _pmt_factor_6, V, 0.7);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_7", _pmt_factor_7, V, 1.);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_8", _pmt_factor_8, V, 1.);		//Relative value of electricity produced during this period compared to the average
	setVar("pmt_factor_9", _pmt_factor_9, V, 1.);		//Relative value of electricity produced during this period compared to the average
	setVar("rec_cost", _rec_cost, V, 84944751.6);		//Receiver cost
	setVar("rec_cost_exp", _rec_cost_exp, V, 0.7, "[-9e9,9e9]");		//Exponent in the equation (total cost) = (ref. cost) * ( (area) / (ref. area) ) ^ X
	setVar("rec_ref_area", _rec_ref_area, V, 1571.);		//Receiver surface area corresponding to the receiver reference cost
	setVar("rec_ref_cost", _rec_ref_cost, V, 126200000., "[-9e9,9e9]");		//Cost of the receiver at the sizing indicated by the reference receiver area
	setVar("sales_tax_cost", _sales_tax_cost, V, 0.);		//Sales tax cost
	setVar("sales_tax_frac", _sales_tax_frac, V, 80.);		//Fraction of the direct capital costs for which sales tax applies
	setVar("sales_tax_rate", _sales_tax_rate, V, 5.);		//Sales tax rate applid to the total direct capital cost
	setVar("site_cost", _site_cost, V, 0.);		//Site improvements cost
	setVar("site_spec_cost", _site_spec_cost, V, 20., "[-9e9,9e9]");		//Cost per square meter of heliostat aperture area of site improvements
	setVar("tes_cost", _tes_cost, V, 0.);		//Thermal storage cost
	setVar("tes_spec_cost", _tes_spec_cost, V, 27.);		//Cost of thermal storage per kilowatt hour (thermal) capacity
	setVar("total_direct_cost", _total_direct_cost, V, 0.);		//Sum of all direct costs
	setVar("total_indirect_cost", _total_indirect_cost, V, 0.);		//Sum of all indirect costs
	setVar("total_installed_cost", _total_installed_cost, V, 0.);		//Sum of direct and indirect costs
	setVar("tower_cost", _tower_cost, V, 14736146.);		//Tower cost
	setVar("tower_exp", _tower_exp, V, 0.0113, "[-9e9,9e9]");		//Exponent in the equation (total cost) = (fixed cost) * exp( X * (tower height) )
	setVar("tower_fixed_cost", _tower_fixed_cost, V, 1927000., "[0,9e9]");		//Fixed tower cost - used as the basis for scaling tower cost as a function of height
	setVar("weekday_sched", _weekday_sched, V, "666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555666666554444444444444555333333332222111111222333333333332222111111222333333333332222111111222333333333332222111111222333666666554444444444444555666666554444444444444555666666554444444444444555");		//Weekday dispatch period schedule
	setVar("weekend_sched", _weekend_sched, V, "666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555666666555555555555555555333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333666666555555555555555555666666555555555555555555666666555555555555555555");		//Weekend dispatch period schedule
	setVar("wiring_cost", _wiring_cost, V, 0.);		//Wiring cost
	setVar("wiring_user_spec", _wiring_user_spec, V, 9., "[-9e9,9e9]");		//Cost of wiring per square meter of heliostat aperture area
fluxsim
	setVar("aim_method", _aim_method, V, 3);		//Method for determining the aim point for each heliostat
	setVar("class_name", _class_name, V, "Performance Simulation");		//Class name
	setVar("cloud_depth", _cloud_depth, V, 250.);		//Depth of the cloud shape
	setVar("cloud_loc_x", _cloud_loc_x, V, 200.);		//Base location of the cloud(s) relative to the tower position - X dimension
	setVar("cloud_loc_y", _cloud_loc_y, V, 200.);		//Base location of the cloud(s) relative to the tower position - Y dimension
	setVar("cloud_opacity", _cloud_opacity, V, 0.8, "[0,1]");		//Fraction of DNI obfuscated by a cloud shadow
	setVar("cloud_sep_depth", _cloud_sep_depth, V, 1.);		//Cloud pattern depth spacing
	setVar("cloud_sep_width", _cloud_sep_width, V, 2.);		//Cloud pattern width spacing
	setVar("cloud_shape", _cloud_shape, V, 0);		//Shape used to model the cloud shadow
	setVar("cloud_skew", _cloud_skew, V, 35., "[-180,180]");		//Angle between North and the depth direction (-180 to +180 with clockwise positive)
	setVar("cloud_width", _cloud_width, V, 500.);		//Width of the cloud shape
	setVar("flux_day", _flux_day, V, 20, "[1,31]");		//Day of the month for the flux simulation
	setVar("flux_dist", _flux_dist, V, 0);		//Sampling basis for random positioning. Non-uniform distributions are weighted away from the center.
	setVar("flux_hour", _flux_hour, V, 12., "[0,24)");		//Hour of the day for the flux simulation
	setVar("flux_model", _flux_model, V, 0);		//Desired flux simulation tool. Not all geometries can be simulated using the Hermite approximation.
	setVar("flux_month", _flux_month, V, 3, "[1,12]");		//Month of the year for the flux simulation
	setVar("flux_solar_az", _flux_solar_az, V, 180.);		//Solar azimuth angle to use for the flux simulation
	setVar("flux_solar_az_in", _flux_solar_az_in, V, 180., "[-180,180]");		//Solar azimuth angle to use for the flux simulation
	setVar("flux_solar_el", _flux_solar_el, V, 85.);		//Solar elevation angle to use for the flux simulation
	setVar("flux_solar_el_in", _flux_solar_el_in, V, 85., "[0,90]");		//Solar elevation angle to use for the flux simulation
	setVar("flux_time_type", _flux_time_type, V, 1);		//Method for specifying the desired flux simulation time.
	setVar("flux_dni", _flux_dni, V, 950.);		//Direct Normal Irradiation at the specified simulation point
	setVar("is_cloud_pattern", _is_cloud_pattern, V, true);		//Create a pattern based on the specified cloud
	setVar("is_cloud_symd", _is_cloud_symd, V, true);		//Mirror the cloud pattern below the width axis
	setVar("is_cloud_symw", _is_cloud_symw, V, true);		//Mirror the cloud pattern to the left of the depth axis
	setVar("is_cloudy", _is_cloudy, V, false);		//Enable simulation for a cloud transient
	setVar("is_optical_err", _is_optical_err, V, true);		//Include the reflector optical error sources in the SolTrace simulation
	setVar("is_sunshape_err", _is_sunshape_err, V, true);		//Include the sun shape error in the SolTrace simulation
	setVar("max_rays", _max_rays, V, 1000000, "[1,1e99]");		//The maximum number of generated rays allowed before terminating the simulation. Overrides the desired rays setting.
	setVar("min_rays", _min_rays, V, 10000, "[1,1e99]");		//The minimum number of ray hits on the receiver before terminating the simulation.
	setVar("norm_dist_sigma", _norm_dist_sigma, V, 0.25, "(0.,1.]");		//Size of the standard distribution relative to half of the height of the receiver.
	setVar("save_data", _save_data, V, false);		//Save the results for each ray
	setVar("save_data_loc", _save_data_loc, V, "soltrace_ray_data.csv");		//Choose a location to save the ray data
	setVar("seed", _seed, V, -1, "[-1, 9e9]");		//The seed for the random number generator
	setVar("sigma_limit", _sigma_limit, V, 2., "[0.,1000]");		//Image positioning cutoff - desired distance of each image in standard deviations from the receiver edge
	setVar("sigma_limit_y", _sigma_limit_y, V, -99., "[0.,1000]");		//Image positioning cutoff in the secondary direction (flat plate receivers only)
	setVar("x_res", _x_res, V, 25, "[1,1000]");		//Number of flux test points per panel (maximum) in the vertical direction for the flux simulation
	setVar("y_res", _y_res, V, 25, "[1,1000]");		//Number of flux test points per panel (maximum) in the horizontal direction for the flux simulation
	setVar("is_autoscale", _is_autoscale, V, true);		//Autoscale the Z-axis of the contour plot
	setVar("plot_zmax", _plot_zmax, V, 1000.);		//Z-axis maximum value
	setVar("plot_zmin", _plot_zmin, V, 0.);		//Z-axis minimum value
	setVar("flux_data", _flux_data, V, "");		//2D matrix of flux data
	setVar("is_load_raydata", _is_load_raydata, V, false);		//Load heliostat field raytrace data from an existing file
	setVar("is_save_raydata", _is_save_raydata, V, false);		//Save heliostat field raytrace data to a file for future re-use
	setVar("raydata_file", _raydata_file, V, "raydata.dat");		//Location and file of the ray data
heliostat
	setVar("a_total", _a_total, V, 0.);		//Aperture area including geometry penalties and gaps in the structure
	setVar("cant_day", _dcant, V, 82, "[1,365]");		//Day of the year used for canting the heliostats (1-365)
	setVar("cant_hour", _hcant, V, 0., "(-12.,12.]");		//Hours past noon at which the mirror panels are canted (-12 to 12)
	setVar("cant_mag_i", _cant_mag_i, V, 0.);		//Total canting vector - i
	setVar("cant_mag_j", _cant_mag_j, V, 0.);		//Total canting vector - j
	setVar("cant_mag_k", _cant_mag_k, V, 0.);		//Total canting vector - k
	setVar("cant_method", _cant_method, V, -1, "[-1,3]");		//Integer to specify the canting method {0=none, -1=Cant on-axis equal to slant range, 1=user-defined on-axis, 3=user-defined off-axis at hour + day}
	setVar("cant_norm_i", _cant_norm_i, V, 0.);		//Normalized canting vector - i
	setVar("cant_norm_j", _cant_norm_j, V, 0.);		//Normalized canting vector - j
	setVar("cant_norm_k", _cant_norm_k, V, 0.);		//Normalized canting vector - k
	setVar("cant_rad_scaled", _rcant_scaled, V, 6., "[-9e9,9e9]");		//Canting radius value (absolute value if radius is not scaled, multiplied by tower height if scaled)
	setVar("cant_radius", _rcant, V, 1000., "(0.,9e99]");		//Radius for canting focal point assuming on-axis canting
	setVar("cant_sun_az", _cant_sun_az, V, 0.);		//Sun azimuth angle at the moment the cant panels are focused on the receiver
	setVar("cant_sun_el", _cant_sun_el, V, 0.);		//Sun elevation angle at the moment the cant panels are focused on the receiver
	setVar("cant_vect_i", _cant_vect.i, V, 0., "[-9e9,9e9]");		//Canting vector - x-component
	setVar("cant_vect_j", _cant_vect.j, V, 0., "[-9e9,9e9]");		//Canting vector y-component
	setVar("cant_vect_k", _cant_vect.k, V, 1., "[-9e9,9e9]");		//Canting vector z-component
	setVar("cant_vect_scale", _cant_vect_scale, V, 400., "[-9e9,9e9]");		//Value to scale the canting unit vector to determine actual canting magnitude
	setVar("class_name", _class_name, V, "Heliostat");		//Class name
	setVar("diameter", _dm, V, 13.77, "(0.,1000.]");		//Diameter of the heliostat structure (round heliostats only)
	setVar("err_azimuth", _sigaz, V, 0., "[0.,1000.]");		//Standard deviation of the normal error dist. of the azimuth angle
	setVar("err_elevation", _sigel, V, 0., "[0.,1000.]");		//Standard deviation of the normal error dist. of the elevation angle
	setVar("err_reflect_x", _sigtx, V, 0.0002, "[0.,1000.]");		//error in reflected vector (horiz.) caused by atmospheric refraction, tower sway, etc.
	setVar("err_reflect_y", _sigty, V, 0.0002, "[0.,1000.]");		//error in reflected vector (vert.) caused by atmospheric refraction, tower sway, etc.
	setVar("err_surface_x", _sigsx, V, 0.00153, "[0.,1000.]");		//Std.dev. of the normal error dist. of the reflective surface normal in the X (horizontal)
	setVar("err_surface_y", _sigsy, V, 0.00153, "[0.,1000.]");		//Same as above, but in the vertical direction
	setVar("err_total", _err_total, V, 0.);		//Total convolved optical error in the reflected beam from the above sources
	setVar("focus_method", _focus_method, V, 1, "[0,3]");		//The focusing method {0=Flat, 1=Each at slant, 2=Average of group, 3=User defined}
	setVar("height", _hm, V, 12.2, "(0.,1000.]");		//Height of the heliostat structure
	setVar("helio_name", _helio_name, V, "Template 1");		//Heliostat template name
	setVar("id", _id, V, -1, "[-1,9e99]");		//Unique ID number for the heliostat template
	setVar("is_cant_rad_scaled", _is_cant_rad_scaled, V, true);		//The cant radius scales with tower height
	setVar("is_cant_vect_slant", _is_cant_vect_slant, V, false);		//Multiply the canting vector by the slant range
	setVar("is_enabled", _is_enabled, V, true);		//Is template enabled?
	setVar("is_faceted", _is_faceted, V, true);		//The number of reflective panels per heliostat is greater than 1
	setVar("is_focal_equal", _is_focal_equal, V, true);		//Both the X and Y focal lengths will use a single value as indicated by the X focal length
	setVar("is_round", _is_round, V, 0 );		//Is the heliostat round (true) or rectangular (false)
	setVar("is_xfocus", _is_xfocus, V, true );		//Reflector is focused in with respect to the heliostat X axis
	setVar("is_yfocus", _is_yfocus, V, true );		//Reflector is focused in with respect to the heliostat Y axis
	setVar("location_x", _location.x, V, 0., "[-9e9,9e9]");		//X Location of heliostat in the field (0,0,Zt) is the location of the tower base
	setVar("location_y", _location.y, V, 0., "[-9e9,9e9]");		//Y Location of heliostat in the field (0,0,Zt) is the location of the tower base
	setVar("location_z", _location.z, V, 0., "[-9e9,9e9]");		//Z Location of heliostat in the field (0,0,Zt) is the location of the tower base
	setVar("n_cant_x", _ncantx, V, 2, "[1,1000]");		//Number of cant panels in the X direction
	setVar("n_cant_y", _ncanty, V, 8, "[1,1000]");		//Number of cant panels in the Y direction
	setVar("n_rot_axes", _nrotax, V, 2, "[0,2]");		//Number of rotational axes on the tracker (1 for LFresnel, 2 for heliostat)
	setVar("r_collision", _rcoll, V, 0., "(0.,1000.]");		//Heliostat reflector maximum footprint diameter
	setVar("ref_total", _ref_total, V, 0.);		//Effective reflectance - product of the mirror reflectance and soiling
	setVar("reflect_ratio", _densmr, V, 0.97, "(0.,1.]");		//Ratio of mirror area to total area of the heliostat defined by wm x hm
	setVar("reflectivity", eff_data.reflectivity, V, 0.95, "(0.,1.]");		//Average reflectivity (clean) of the mirrored surface
	setVar("rvel_max_x", _maxrvelx, V, 1000., "(0.,9e99]");		//maximum rotational velocity about the x axis
	setVar("rvel_max_y", _maxrvelz, V, 1000., "(0.,9e99]");		//maximum rotational velocity about the z axis
	setVar("soiling", eff_data.soiling, V, 0.95, "[0.,1.]");		//Average soiling factor
	setVar("temp_az_max", _temp_az_max, V, 180., "[-180.,180]");		//Angular boundary for heliostat geometry - on the clockwise side of the region
	setVar("temp_az_min", _temp_az_min, V, -180., "[-180.,180]");		//Angular boundary for heliostat geometry - on the counter-clockwise side of the region
	setVar("temp_rad_max", _temp_rad_max, V, 7.5, "[0,9e9]");		//Maximum radius at which this heliostat geometry can be used
	setVar("temp_rad_min", _temp_rad_min, V, 0.75, "[0,9e9]");		//Minimum radius at which this heliostat geometry can be used
	setVar("type", _type, V, 0, "[0,9e9]");		//Integer used to group heliostats into geometries within a field, (e.g. 5 different focal length designs)
	setVar("template_order", _template_order, V, -1);		//template_order
	setVar("width", _wm, V, 12.2, "(0.,1000.]");		//Width of the heliostat structure
	setVar("x_focal_length", _xfocal, V, 1000., "(0.,9e99]");		//Reflector focal length with respect to the heliostat X (horizontal) axis
	setVar("x_gap", _wgap, V, 0., "[0.,1000.]");		//Separation between panels in the horizontal direction
	setVar("y_focal_length", _yfocal, V, 1000., "(0.,9e99]");		//Reflector focal length with respect to the heliostat Y (vertical) axis
	setVar("y_gap", _hgap, V, 0., "[0.,1000.]");		//Separation between panels in the vertical direction
	setVar("track_method", _track_method, V, 0);		//Specify how often heliostats update their tracking position 
	setVar("track_period", _track_period, V, 10., "[0,99999]");		//The amount of time between tracking updates for each heliostat
land
	setVar("class_name", _class_name, V, "Land");		//Class name
	setVar("exclusions", _exclusions, V);		//Vector of arrays that specify the regions of land to exclude in the heliostat layout
	setVar("import_tower_lat", _import_tower_lat, V, 0., "[-180,180]");		//Imported land boundary tower latitude
	setVar("import_tower_lon", _import_tower_lon, V, 0., "[-90,90]");		//Imported land boundary tower longitude
	setVar("import_tower_set", _import_tower_set, V, false);		//Has the tower location been set for imported land geometries?
	setVar("inclusions", _inclusions, V);		//Vector of arrays that specify the regions of land to include in the heliostat layout
	setVar("is_bounds_array", _is_bounds_array, V, false);		//Land boundary is specified by points array
	setVar("is_bounds_fixed", _is_bounds_fixed, V, false);		//Land boundary has fixed limits (not more than | not less than)
	setVar("is_bounds_scaled", _is_bounds_scaled, V, true);		//Land boundary scales with tower hight value
	setVar("is_land_max_opt", _is_land_max_opt, V, true);		//Optimize outer land boundary
	setVar("is_land_max_restrict", _is_land_max_restrict, V, false);		//Restrict outer land boundary range
	setVar("land_max_opt_max", _land_max_opt_max, V, 6., "[1,20]");		//Maximum outer boundary value
	setVar("land_max_opt_min", _land_max_opt_min, V, 23., "[1,20]");		//Minimum outer boundary value
	setVar("max_fixed_rad", _max_fixed_rad, V, 1500., "(0.,9e99]");		//Outer land boundary for circular land plot
	setVar("max_scaled_rad", _max_scaled_rad, V, 7.5, "(0.,100.]");		//Maximum radius (in units of tower height) for positioning of the heliostats
	setVar("min_fixed_rad", _min_fixed_rad, V, 100., "(0.,9e99]");		//Inner land boundary for circular land plot
	setVar("min_scaled_rad", _min_scaled_rad, V, 0.75, "[0.,100.]");		//Minimum radius (in units of tower height) for positioning of the heliostats
	setVar("topo_grid", _topo_grid, V);		//Regular grid of the land topology of the solar field
	setVar("bound_area", bound_area, V, 0.);		//Land area occupied by heliostats. This value is the area of a convex hull surrounding the heliostat positions.
optimize
	setVar("class_name", _class_name, V, "Optimization");		//
	setVar("aspect_display", _aspect_display, V);		//Current receiver aspect ratio (H/W)
	setVar("converge_tol", _converge_tol, V, 0.001);		//Relative change in the objective function below which convergence is achieved
	setVar("flux_penalty", _flux_penalty, V, 0.35);		//Relative weight in the objective function given to flux intensity over the allowable limit
	setVar("gs_refine_ratio", _gs_refine_ratio, V);		//The relative step size of the refined area during refinement simulations. More iterations will allow greater refinement
	setVar("max_desc_iter", _max_desc_iter, V, 20);		//Maximum number of steps along the direction of steepest descent before recalculating the response surface
	setVar("max_gs_iter", _max_gs_iter, V, 5);		//Maximum number of golden section iterations to refine the position of a local minimum
	setVar("max_iter", _max_iter, V, 200);		//Maximum number of times the optimization can iterate
	setVar("max_step", _max_step, V, 0.02);		//Maximum total relative step size during optimization
	setVar("power_penalty", _power_penalty, V, 0.5);		//Relative weight in the objective function given to power to the receiver below the required minimum
	setVar("algorithm", _algorithm, V, 0);		//Optimization algorithm
parametric
	setVar("class_name", _class_name, V, "Parametric Simulation");		//Class name
	setVar("eff_file_name", _eff_file_name, V, "eff_array.dat");		//Name of the output file containing the efficiency matrix
	setVar("flux_file_name", _flux_file_name, V, "fluxmap.csv");		//Name of the output file containing the fluxmap data
	setVar("fluxmap_format", _fluxmap_format, V, 0);		//Dimensions of the fluxmap data (rows,cols)
	setVar("is_fluxmap_norm", _is_fluxmap_norm, V, true);		//Flux data is reported as normalized
	setVar("par_save_field_img", _par_save_field_img, V, false);		//Save field efficiency image
	setVar("par_save_flux_dat", _par_save_flux_dat, V, false);		//Save receiver flux data
	setVar("par_save_flux_img", _par_save_flux_img, V, false);		//Save receiver flux image
	setVar("par_save_helio", _par_save_helio, V, false);		//Save detailed heliostat performance data for each run
	setVar("par_save_summary", _par_save_summary, V, false);		//Save detailed system performance data to a file for each run
	setVar("sam_out_dir", _sam_out_dir, V, "");		//Output directory
	setVar("user_par_values", _user_par_values, V, "");		//User parametric values
plant
	setVar("class_name", _class_name, V, "Power Cycle and BOP");		//Class name
	setVar("eta_cycle", _eta_cycle, V, 0.425, "(0.,1]");		//Thermodynamic efficiency of the power cycle, including feedwater pumps and cooling equipment parasitics
	setVar("hours_tes", _hours_tes, V, 6., "[0.,100]");		//Capacity of Hours of thermal storage operation at full cycle output
	setVar("par_factor", _par_factor, V, 0.87, "(0.,1]");		//Estimated ratio of net power output to gross power output at design
	setVar("power_gross", _power_gross, V, 115., "(0,9e9]");		//Rated nameplate design gross turbine electric output, not accounting for parasitic losses
	setVar("power_net", _power_net, V, 100., "(0,9e9]");		//Estimated net electric power at design, accounting for all parasitic losses
	setVar("power_net_max", _power_net_max, V, 100., "[0,9e9]");		//Maximum net electric power rating considered for optimization - calculated from Layout page
	setVar("power_net_min", _power_net_min, V, 100., "[0,9e9]");		//Minimum net electric power rating considered for optimization - calculated from Layout page
	setVar("solar_mult", _solar_mult, V, 1.9, "(0.,100]");		//Ratio of thermal power output from the solar field to power cycle thermal input at design
receiver
	setVar("absorber_area", _absorber_area, V, 0., "[-9e9,9e9]");		//Effective area of the receiver absorber panels
	setVar("absorptance", _absorptance, V, 0.94, "(0.,1.]");		//Energy absorbed by the receiver surface before accounting for radiation/convection losses
	setVar("accept_ang_type", _accept_ang_type, V, 0);		//Receiver angular acceptance window defines angles about the aperture normal, can be rectangular or elliptical shape
	setVar("accept_ang_x", _accept_ang_x, V, 180., "[0,180]");		//Acceptance angle of the receiver in the horizontal direction (in aperture coordinates)
	setVar("accept_ang_y", _accept_ang_y, V, 180., "[0,180]");		//Acceptance angle of the receiver in the vertical direction (in aperture coordinates)
	setVar("aperture_type", _aperture_type, V, 0);		//The shape of the receiver aperture
	setVar("aspect_opt_max", _aspect_opt_max, V, 2., "[0.,1000.]");		//Maximum receiver aspect ratio during optimization
	setVar("aspect_opt_min", _aspect_opt_min, V, 0.5, "[0.,1000.]");		//Minimum receiver aspect ratio during optimization
	setVar("class_name", _class_name, V, "Receiver");		//Class name
	setVar("height_opt_max", _height_opt_max, V, 30., "[0.,1000.]");		//Maximum receiver height during optimization
	setVar("height_opt_min", _height_opt_min, V, 5., "[0.,1000.]");		//Minimum receiver height during optimization
	setVar("id", _id, V, -1, "[-1,9e99]");		//Template ID
	setVar("is_aspect_opt", _is_aspect_opt, V, true);		//Optimize receiver aspect ratio (height / width)
	setVar("is_aspect_restrict", _is_aspect_restrict, V, false);		//Restrict aspect ratio range (height / width)
	setVar("is_enabled", _is_enabled, V, true);		//Is template enabled?
	setVar("is_height_opt", _is_height_opt, V, true);		//Optimize receiver height
	setVar("is_height_restrict", _is_height_restrict, V, false);		//Restrict receiver height range
	setVar("is_open_geom", _is_open_geom, V, false);		//If true, the receiver is represented by an arc rather than a closed circle/polygon
	setVar("is_polygon", _is_polygon, V, false);		//Receiver geometry is represented as discrete polygon of N panels rather than continuous arc
	setVar("n_panels", _n_panels, V, 12, "[3,30]");		//Number of receiver panels (polygon facets) for a polygonal receiver geometry
	setVar("optical_height", _opt_height, V, 180., "(0.,1000.]");		//Calculated height of the centerline of the receiver above the plane of the heliostats
	setVar("panel_rotation", _panel_rotation, V, 0., "[-180.,180.]");		//Azimuth angle between the normal vector to the primary 'north' panel and North
	setVar("peak_flux", _peak_flux, V, 800., "(0.,9e9]");		//Maximum allowable flux intensity on any portion of the receiver surface
	setVar("piping_loss", _piping_loss, V, 0.);		//Thermal loss from non-absorber receiver piping
	setVar("piping_loss_coef", _piping_loss_coef, V, 10.2, "[0,9e9]");		//Loss per meter of tower height
	setVar("piping_loss_const", _piping_loss_const, V, 0., "[0,9e9]");		//Constant thermal loss due to piping - doesn't scale with tower height
	setVar("rec_aspect", _rec_aspect, V, 1.2, "(0.,9e9]");		//Ratio of receiver height to width
	setVar("rec_azimuth", _rec_az, V, 0., "[-180.,180]");		//Receiver azimuth orientation: 0 deg is north, positive clockwise
	setVar("rec_cav_cdepth", _rec_cav_cdepth, V, 0., "[-100.,100]");		//Offset of centroid of cavity absorber surface from the aperture plane. (Positive->Increased depth)
	setVar("rec_cav_rad", _rec_cav_rad, V, 7.75, "(0.,100]");		//Radius of the receiver cavity absorbing surface
	setVar("rec_diameter", _d, V, 15.5, "[0.,1000.]");		//Receiver diameter for cylindrical receivers
	setVar("rec_elevation", _rec_elevation, V, 0., "[-90.,90.]");		//Receiver elevation orientation: 0 deg to the horizon, negative rotating downward
	setVar("rec_height", _h, V, 22., "(0.,1000.]");		//Height of the absorbing component
	setVar("rec_name", _rec_name, V, "Receiver 1");		//Receiver template name
	setVar("rec_offset_x", _rec_offset_x, V, 0., "[-9e9,9e9]");		//Offset of receiver center in the East(+)/West(-) direction from the tower
	setVar("rec_offset_y", _rec_offset_y, V, 0., "[-9e9,9e9]");		//Offset of receiver center in the North(+)/South(-) direction from the tower
	setVar("rec_offset_z", _rec_offset_z, V, 0., "[-9e9,9e9]");		//Offset of the receiver center in the vertical direction, positive upwards
	setVar("rec_type", _rec_type, V, 0, "[0,5]");		//Receiver geometrical configuration
	setVar("rec_width", _w, V, 15.5, "[0.,1000.]");		//Receiver width for cavity or flat receivers
	setVar("span_max", _span_max, V, -270.);		//Maximum (CW) bound of the arc defining the receiver surface
	setVar("span_min", _span_min, V, -90.);		//Minimum (CCW) bound of the arc defining the receiver surface
	setVar("therm_loss", _therm_loss, V, 0.);		//Receiver thermal loss at design
	setVar("therm_loss_base", _therm_loss_base, V, 30., "[0,9e9]");		//Thermal loss from the receiver at design-point conditions
	setVar("therm_loss_load", _therm_loss_load, V);		//Temperature-dependant thermal loss
	setVar("therm_loss_wind", _therm_loss_wind, V);		//Wind speed-dependant thermal loss
solarfield
	setVar("accept_max", _accept_max, V["solarfield"][var_index], 180., "[-180.,180.]");		//Upper bound of the angular range containing the heliostat field
	setVar("accept_min", _accept_min, V["solarfield"][var_index], -180., "[-180.,180.]");		//Lower bound of the angular range containing the heliostat field
	setVar("az_spacing", _az_spacing, V["solarfield"][var_index], 2., "[1.,1000.]");		//Azimuthal spacing factor for the first row of heliostats after a reset. Heliostats separated by heliostat width times this factor.
	setVar("class_name", _class_name, V["solarfield"][var_index], "Solar Field");		//Class name
	setVar("des_sim_detail", _des_sim_detail, V["solarfield"][var_index], 5, "[0,4]");		//Simulation detail for placing heliostats (see definitions in options spreadsheet)
	setVar("des_sim_ndays", _des_sim_ndays, V["solarfield"][var_index], 4, "(1,365]");		//For limited annual simulation, the number of evenly spaced days to simulate
	setVar("des_sim_nhours", _des_sim_nhours, V["solarfield"][var_index], 2, "[1,5]");		//Simulation will run with the specified hourly frequency (1=every hour, 2=every other hour...)
	setVar("dni_des", _dni_des, V["solarfield"][var_index], 950., "(0.,1300.]");		//DNI value at which the design-point receiver thermal power is achieved
	setVar("hsort_method", _hsort_method, V["solarfield"][var_index], 7);		//Select the criteria by which heliostats will be included in the solar field layout.
	setVar("is_opt_zoning", _is_opt_zoning, V["solarfield"][var_index], true);		//Enables grouping of heliostats into zones for intercept factor calculation during layout only
	setVar("is_power_opt", _is_power_opt, V["solarfield"][var_index], false);		//Vary the power output during optimization to identify optimal level?
	setVar("is_power_restrict", _is_power_restrict, V["solarfield"][var_index], false);		//Restrict the search range for power output to the indicated limits
	setVar("is_prox_filter", _is_prox_filter, V["solarfield"][var_index], false);		//Post-process the layout to select heliostats that are closer to the tower.
	setVar("is_tht_opt", _is_tht_opt, V["solarfield"][var_index], true);		//Vary the tower height during optimization to identify optimal level?
	setVar("is_tht_restrict", _is_tht_restrict, V["solarfield"][var_index], false);		//Restrict the search range for tower height to the indicated limits
	setVar("layout_data", _layout_data, V["solarfield"][var_index], "");		//Layout data in string form
	setVar("layout_method", _layout_method, V["solarfield"][var_index], 1, "[0,99]");		//Field layout method
	setVar("trans_limit_fact", _trans_limit_fact, V["solarfield"][var_index], 1., "[0,999]");		//Determines the point at which close-packing switches to standard layout. =1 at no-blocking transition limit.
	setVar("max_zone_size_az", _max_zone_size_az, V["solarfield"][var_index], 1., "(0,100]");		//Maximum zone size (azimuthal direction) for grouping optical intercept factor calculations
	setVar("max_zone_size_rad", _max_zone_size_rad, V["solarfield"][var_index], 1., "(0,100]");		//Maximum zone size (radial direction) for grouping optical intercept factor calculations
	setVar("min_zone_size_az", _min_zone_size_az, V["solarfield"][var_index], 0.1, "(0,100]");		//Minimum zone size (azimuthal direction) for grouping optical intercept factor calculations
	setVar("min_zone_size_rad", _min_zone_size_rad, V["solarfield"][var_index], 0.1, "(0,100]");		//Minimum zone size (radial direction) for grouping optical intercept factor calculations
	setVar("prox_filter_frac", _prox_filter_frac, V["solarfield"][var_index], 0.03, "[0.,1)");		//Fraction of heliostats to subject to proximity filter.
	setVar("q_des", _q_des, V["solarfield"][var_index], 500., "(0.,99999.]");		//Design thermal power delivered from the solar field
	setVar("q_des_opt_max", _q_des_opt_max, V["solarfield"][var_index], 1000., "(0.,99999.]");		//Maximum possible solar field design power during optimzation
	setVar("q_des_opt_min", _q_des_opt_min, V["solarfield"][var_index], 100., "(0.,99999.]");		//Minimum possible solar field design power during optimzation
	setVar("rad_spacing_method", _rad_spacing_method, V["solarfield"][var_index], 3, "[1,3]");		//Method for determining radial spacing during field layout for radial-stagger
	setVar("row_spacing_x", _row_spacing_x, V["solarfield"][var_index], 1.1, "(1,1000.]");		//Separation between adjacent heliostats in the X-direction, multiplies heliostat radius
	setVar("row_spacing_y", _row_spacing_y, V["solarfield"][var_index], 1.1, "(1,1000.]");		//Separation between adjacent heliostats in the Y-direction, multiplies heliostat radius
	setVar("shadow_height", _towL, V["solarfield"][var_index], _tht, "(0.,1000.]");		//Effective tower height for shadowing calculations
	setVar("shadow_width", _towD, V["solarfield"][var_index], 16., "(0.,1000.]");		//Effective tower diameter for shadowing calculations
	setVar("sim_step_data", _sim_step_data, V["solarfield"][var_index]);		//Data used for design simulations
	setVar("sim_time_step", _sim_time_step, V["solarfield"][var_index], 0.);		//Simulation weather data time step
	setVar("spacing_reset", _spacing_reset, V["solarfield"][var_index], 1.33, "(1.,1000.]");		//For heliostat layout - ratio of maximum to initial azimuthal spacing before starting new compressed row
	setVar("sun_loc_des", _sun_loc_des, V["solarfield"][var_index], 0);		//Sun location when thermal power rating is achieved
	setVar("sun_loc_des_az", _sun_loc_des_az, V["solarfield"][var_index], 180., "[-180.,180.]");		//Solar azimuth angle at the design point
	setVar("sun_loc_des_el", _sun_loc_des_el, V["solarfield"][var_index], 85., "[0.,90]");		//Solar elevation angle at the design point
	setVar("temp_which", _temp_which, V["solarfield"][var_index], 0);		//Select the heliostat geometry template that will be used in the layout
	setVar("template_rule", _template_rule, V["solarfield"][var_index], 0);		//Method for distributing heliostat geometry templates in the field
	setVar("tht", _tht, V["solarfield"][var_index], 180., "(0.,1000.]");		//Average height of the tower receiver centerline above the base heliostat pivot point elevation
	setVar("tht_opt_max", _tht_opt_max, V["solarfield"][var_index], 225., "(0.,1000.]");		//Maximum allowable tower height during optimization
	setVar("tht_opt_min", _tht_opt_min, V["solarfield"][var_index], 125., "(0.,1000.]");		//Minimum allowable tower height during optimization
	setVar("xy_field_shape", _xy_field_shape, V["solarfield"][var_index], 0, "[0,2]");		//Enforced shape of the heliostat field
	setVar("xy_rect_aspect", _xy_rect_aspect, V["solarfield"][var_index], 1., "(0.,1000.]");		//Aspect ratio of the rectangular field layout (height in Y / width in X)
	setVar("zone_div_tol", _zone_div_tol, V["solarfield"][var_index], 0.001, "[0.001,1]");		//Allowable variation in optical intercept factor within a layout zone
custom_rec
	setVar("A_proj", _A_proj, V, 0.);		//Projected absorber area
	setVar("A_tot", _A_tot, V, 0.);		//Total absorber surface area
	setVar("base_name", _base_name, V, "nbb_co2");		//Base name for output data. Directory will be appended with simulation number for multiple sims.
	setVar("basis_method", _basis_method, V, 0);		//Metric to use as base flux value in determining profile quality
	setVar("basis_specified", _basis_specified, V, 0.);		//Metric to use as base flux value in determining profile quality
	setVar("cav_depth", _cav_depth, V, 3.);		//Length between aperture and back wall
	setVar("circ_min", _circ_min, V, 0., "[0.,1.]");		//Minimum flux value (multiplied by max. value) in the circumferential profile.
	setVar("circ_profile", _circ_profile, V, 0);		//Method for generating circumferential flux profile based on available data points
	setVar("circ_res", _circ_res, V, 20, "[2,9999]");		//Number of points in the circumferential flux profile
	setVar("class_name", _class_name, V, "NBB s-CO2 Receiver");		//Class name
	setVar("D_header", _D_header, V, 0.1);		//Header diameter
	setVar("d_tube", _d_tube, V, 0.02);		//Individual tube outer diameter
	setVar("design_location", _design_location, V, 0);		//Flux criteria to determine the tube design point location
	setVar("ees_path", _ees_path, V, "C:\\EES32\\ees.exe");		//EES executable location
	setVar("enable_custom", _enable_custom, V, false);		//Use the custom receiver geometry functionality
	setVar("enable_ees", _enable_ees, V, false);		//Run the tube strain model according to the specified settings
	setVar("est_flux", _est_flux, V, 0.);		//Average flux on absorber panels at design
	setVar("export_quality", _export_quality, V, true);		//Save tabulated flux quality results to the output directory
	setVar("f_h_bend", _f_h_bend, V, 0.9);		//Bend vertical fill
	setVar("f_offset_zm", _f_offset_zm, V, 0.);		//Fraction of the total cavity depth by which the absorber is displaced from the back wall
	setVar("f_offset_zp", _f_offset_zp, V, 0.);		//Fraction of the total cavity depth by which the absorber is displaced from the aperture
	setVar("f_shield", _f_shield, V, 0.);		//Shield aperture occupancy fraction
	setVar("f_x_abs", _f_x_abs, V, 1.);		//Absorber horizontal occupancy factor
	setVar("f_x_sep", _f_x_sep, V, 1.);		//Factor multiplying spacing length between vertical panels. Max should be (n-1)/(n-3) for n>3
	setVar("f_y_abs", _f_y_abs, V, 1.);		//Factor multiplying spacing length between horizontal panels. Max should be (n-1)/(n-3) for n>3
	setVar("flux_adjust", _flux_adjust, V, 0.);		//Flux magnitude multiplier
	setVar("generate_plots", _generate_plots, V, true);		//Generate surface flux plots
	setVar("generate_profiles", _generate_profiles, V, false);		//Generate surface flux data files
	setVar("h_rec", _h_rec, V, 8.);		//Receiver total height
	setVar("header_domain", _header_domain, V, 0);		//Method for dividing a flux panel into header sections
	setVar("inlet_temp", _inlet_temp, V, 470.);		//Design-point receiver inlet temperature
	setVar("is_results_window", _is_results_window, V, true);		//Show results window
	setVar("L_shield_ext", _L_shield_ext, V, 0.05);		//Shield additional coverage depth
	setVar("link_opt_props", _link_opt_props, V, false);		//Overwrite the specified separator optical properties with absorber properties
	setVar("n_abs", _n_abs, V, 8, "[2,999]");		//Number of absorber racks vertically
	setVar("n_sep", _n_sep, V, 2, "[2,999]");		//Number of optical separation panels
	setVar("N_tubes", _N_tubes, V, 0);		//Number of tubes in the receiver
	setVar("outlet_temp", _outlet_temp, V, 650.);		//Design-point receiver outlet temperature
	setVar("p_out", p_out, V, 0.);		//Tube outlet pressure
	setVar("profile_name", profile_name, V, "none");		//Flux profile location
	setVar("q_ray", _q_ray, V, 100.);		//Power per ray
	setVar("quality_method", _quality_method, V, 0);		//Method for calculating the quality of the flux profile
	setVar("rec_mass_flow", _rec_mass_flow, V, 0.);		//Mass flow rate of the CO2 through the entire receiver
	setVar("rec_pressure", _rec_pressure, V, 25., "[7.5,40]");		//Turbine inlet pressure
	setVar("rho_abs", _rho_abs, V, 0.5);		//Absorber reflectivity
	setVar("rho_cav", _rho_cav, V, 0.95);		//Cavity wall reflectivity
	setVar("rho_sep", _rho_sep, V, 0.95);		//Separator reflectivity
	setVar("rho_shield", _rho_shield, V, 0.9);		//Shield reflectivity
	setVar("sep_are_abs", _sep_are_abs, V, false);		//Treat separators as absorbers
	setVar("sigma_s_abs", _sigma_s_abs, V, 5.);		//Absorber specularity
	setVar("sigma_s_cav", _sigma_s_cav, V, 0.75);		//Cavity wall specularity
	setVar("sigma_s_sep", _sigma_s_sep, V, 0.75);		//Separator specularity
	setVar("sigma_s_shield", _sigma_s_shield, V, 0.75);		//Shield specularity
	setVar("sim_res", _sim_res, V, 20, "[1,9999]");		//Simulation discretization along each flow path
	setVar("T_eval_max", T_eval_max, V, 0.);		//Maximum material temperature
	setVar("T_surf_max", T_surf_max, V, 0.);		//Maximum surface temperature
	setVar("tau_abs", _tau_abs, V, 0.);		//Absorber transmissivity
	setVar("tau_cav", _tau_cav, V, 0.);		//Cavity wall transmissivity
	setVar("tau_sep", _tau_sep, V, 0.);		//Separator transmissivity
	setVar("tau_shield", _tau_shield, V, 0.);		//Shield transmissivity
	setVar("theta_bend", _theta_bend, V, 120.);		//Absorber bend angle 
	setVar("theta_shield", _theta_shield, V, 35.);		//Angle between shield surfaces
	setVar("tube_length_abs", _tube_length_abs, V, 3.);		//Total tubing length for a tube in the absorber panel
	setVar("tube_length_sep", _tube_length_sep, V, 3.);		//Total tubing length for a tube in the separator panel
	setVar("tube_material", _tube_material, V, 0);		//Tube material
	setVar("tube_mdot", tube_mdot, V, 0.);		//Tube mass flow rate at design
	setVar("tube_qdot", tube_qdot, V, 0.);		//Energy absorbed in design tube
	setVar("tube_rough", _tube_rough, V, 3.00E-06);		//Tube internal roughness
	setVar("tube_thickness", tube_thickness, V, 0.);		//Calculated tube thickness
	setVar("w_rec", _w_rec, V, 8.);		//Receiver total width
	setVar("x_bins", _x_bins, V, 15);		//Number of surface bins (X)
	setVar("y_bins", _y_bins, V, 15);		//Number of surface bins (Y)
